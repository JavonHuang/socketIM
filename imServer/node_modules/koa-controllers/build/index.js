"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
require("reflect-metadata");
const Router = require("koa-router");
const _ = require("lodash");
const bodyParser = require("koa-bodyparser");
const glob = require("glob");
const index_1 = require("./error/index");
const index_2 = require("./validation/index");
const Multer = require('koa-multer');
__export(require("./decorators/Controller"));
__export(require("./decorators/Get"));
__export(require("./decorators/Post"));
__export(require("./decorators/Ctx"));
__export(require("./decorators/RequestParam"));
__export(require("./decorators/Before"));
const router = new Router();
const controllers = {};
const controllerMethodRouters = {};
const controllerMethodParamMetas = {};
let controllerOptions;
let multer;
function useControllers(app, controllerFiles, options) {
    controllerOptions = options;
    multer = Multer(options.multipart);
    app.use(bodyParser());
    const files = glob.sync(controllerFiles);
    _.each(files, (file) => {
        require(file);
    });
    _.each(controllerMethodRouters, (routers) => {
        _.each(routers, (routerDetail) => {
            router[routerDetail.requestMethod](routerDetail.path, ...createRouterHandler(routerDetail));
        });
    });
    app.use(router.routes())
        .use(router.allowedMethods());
}
exports.useControllers = useControllers;
function addRouter(path, target, propertyKey, method) {
    const controllerName = target.constructor.name;
    const methodRouters = getMethodRouters(controllerName);
    const metas = controllerMethodParamMetas[controllerName] ?
        controllerMethodParamMetas[controllerName][propertyKey] : undefined;
    const paramTypes = Reflect.getMetadata('design:paramtypes', target, propertyKey);
    methodRouters[propertyKey] = _.merge(methodRouters[propertyKey], {
        path,
        paramTypes,
        requestMethod: method,
        controller: controllerName,
        controllerMethod: propertyKey,
        methodParamMetas: metas,
    });
}
exports.addRouter = addRouter;
function addRouterMiddleware(middleware, target, propertyKey) {
    const controllerName = target.constructor.name;
    const methodRouters = getMethodRouters(controllerName);
    let existBefores = false;
    if (methodRouters[propertyKey]) {
        const befores = methodRouters[propertyKey].befores;
        if (befores) {
            existBefores = true;
            befores.push(middleware);
        }
    }
    if (!existBefores) {
        methodRouters[propertyKey] = _.merge(methodRouters[propertyKey], {
            befores: [middleware],
        });
    }
}
exports.addRouterMiddleware = addRouterMiddleware;
function addController(target) {
    controllers[target.name] = new target();
}
exports.addController = addController;
function addParam(target, propertyKey, index, injector, meta) {
    const params = getMethodParams(target, propertyKey);
    params[index] = {
        decorator: injector,
        additionalMeta: meta,
    };
}
exports.addParam = addParam;
function createRouterHandler(routerDetail) {
    const handlers = [];
    if (routerDetail.befores) {
        _.each(routerDetail.befores, (before) => {
            handlers.push((new before()).middleware);
        });
    }
    handlers.push((ctx, next) => __awaiter(this, void 0, void 0, function* () {
        try {
            yield controllers[routerDetail.controller][routerDetail.controllerMethod].apply(controllers[routerDetail.controller], yield getHandlerInjectParams(ctx, routerDetail));
        }
        catch (error) {
            if (error instanceof index_1.RequestParamError) {
                ctx.throw(400, error.message);
            }
            else {
                throw error;
            }
        }
        yield next();
    }));
    return handlers;
}
function getHandlerInjectParams(ctx, routerDetail) {
    return __awaiter(this, void 0, void 0, function* () {
        if (routerDetail.methodParamMetas == null) {
            return [];
        }
        else {
            const params = [];
            if (isMultipart(ctx)) {
                yield uploadMultipartFile(ctx, routerDetail);
            }
            for (let i = 0, len = _.size(routerDetail.methodParamMetas); i < len; i += 1) {
                const paramMeta = routerDetail.methodParamMetas[i];
                const paramType = routerDetail.paramTypes[i].name.toLowerCase();
                switch (paramMeta.decorator) {
                    case 'ctx':
                        params.push(ctx);
                        break;
                    case 'request-param':
                        const requestParamMeta = paramMeta.additionalMeta;
                        if (requestParamMeta == null) {
                            throw new index_1.RequestParamError('request param options should not be null');
                        }
                        let parsedValue = getRequestParam(ctx, paramType, requestParamMeta);
                        if (parsedValue == null) {
                            if (!isNotRequired(requestParamMeta)) {
                                const defaultValue = getDefault(requestParamMeta);
                                if (defaultValue == null) {
                                    throw new index_1.RequestParamError('required request param is not present: ' + requestParamMeta.name);
                                }
                                parsedValue = defaultValue;
                            }
                        }
                        params.push(parsedValue);
                        break;
                    default:
                        throw new Error('unsupport param injector: ' + paramMeta.decorator);
                }
            }
            return params;
        }
    });
}
function uploadMultipartFile(ctx, routerDetail) {
    return __awaiter(this, void 0, void 0, function* () {
        const fileFields = getRouterFileFields(routerDetail);
        yield multer.fields(fileFields)(ctx);
    });
}
function getRouterFileFields(routerDetail) {
    const fileFields = [];
    if (routerDetail.methodParamMetas != null) {
        _.each(routerDetail.methodParamMetas, (paramMeta) => {
            if (paramMeta.decorator === 'request-param'
                && paramMeta.additionalMeta != null
                && paramMeta.additionalMeta.options != null
                && paramMeta.additionalMeta.options.file === true) {
                fileFields.push({
                    name: paramMeta.additionalMeta.name,
                });
            }
        });
    }
    return fileFields;
}
function getUploadFile(ctx, requestParamMeta) {
    if (_.isObject(ctx.req.files) && _.isArray(ctx.req.files[requestParamMeta.name])) {
        const files = ctx.req.files[requestParamMeta.name];
        if (requestParamMeta.options && requestParamMeta.options.multiple) {
            return files;
        }
        else {
            return files[0];
        }
    }
}
function isFile(meta) {
    return !!(meta && meta.options && meta.options.file);
}
function getRequestParam(ctx, paramType, meta) {
    if (isFile(meta)) {
        return getUploadFile(ctx, meta);
    }
    if (meta === null) {
        return undefined;
    }
    let value;
    if (ctx.req.method === 'GET') {
        value = ctx.query[meta.name];
    }
    else if (isWwwFormUrlencoded(ctx)) {
        value = ctx.request.body[meta.name];
    }
    else if (isMultipart(ctx)) {
        value = ctx.req.body[meta.name];
    }
    if (value != null) {
        const convertedValue = convertValue(value, paramType, meta);
        index_2.validateValue(convertedValue, paramType, meta);
        return convertedValue;
    }
}
function isWwwFormUrlencoded(ctx) {
    const contentType = ctx.headers['content-type'];
    return contentType === 'application/x-www-form-urlencoded';
}
function isMultipart(ctx) {
    const contentType = ctx.headers['content-type'];
    return typeof contentType === 'string' && contentType.indexOf('multipart/form-data') !== -1;
}
function convertValue(value, paramType, meta) {
    if (meta.options != null && meta.options.enum != null) {
        return meta.options.enum[value];
    }
    switch (paramType) {
        case 'number':
            if (value === '') {
                return undefined;
            }
            else {
                const number = +value;
                if (isNaN(number)) {
                    throw new index_1.RequestParamError('request param parse fail: invalid number: ' + value);
                }
                return number;
            }
        case 'string':
            return value;
        case 'boolean':
            if (value === 'true') {
                return true;
            }
            else if (value === 'false') {
                return false;
            }
            else {
                return !!value;
            }
        default:
            return value;
    }
}
function isNotRequired(meta) {
    return !!(meta && meta.options && meta.options.required === false);
}
function getDefault(meta) {
    if (meta && meta.options) {
        return meta.options.default;
    }
}
function getMethodParams(target, propertyKey) {
    const controllerName = target.constructor.name;
    if (controllerMethodParamMetas[controllerName] == null) {
        controllerMethodParamMetas[controllerName] = {};
    }
    if (controllerMethodParamMetas[controllerName][propertyKey] == null) {
        controllerMethodParamMetas[controllerName][propertyKey] = {};
    }
    return controllerMethodParamMetas[controllerName][propertyKey];
}
function getMethodRouters(controllerName) {
    if (controllerMethodRouters[controllerName] == null) {
        controllerMethodRouters[controllerName] = {};
    }
    return controllerMethodRouters[controllerName];
}
//# sourceMappingURL=index.js.map